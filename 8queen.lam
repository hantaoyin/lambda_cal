(^ f b -> b f) (^ f b -> b f)
^ define ->

define (^ x -> x) ^ id ->
define (^ c x -> c) ^ const ->

define (^ f -> (^ x -> f (x x)) (^ x -> f (x x)))
^ fix ->

define (^ x y -> x) ^ true ->
define (^ x y -> y) ^ false ->
define (^ b x y -> b y x) ^ not ->
define (^ a b -> a b false) ^ and ->
define (^ a b -> a true b) ^ or ->

define (^ x y f -> f x y) ^ cons ->
define (^ p -> p true) ^ car ->
define (^ p -> p false) ^ cdr ->
define false ^ nil ->
define (^ p -> p (^ _ _ _ -> false) true) ^ isNil ->
define (^ p -> not (isNil p)) ^ isPair ->

define (fix (^ map f xs -> (isNil xs) nil (cons (f (car xs)) (map f (cdr xs)))))
^ map ->

define (fix (^ filter f xs ->
	(isNil xs) nil ((f (car xs)) (cons (car xs) (filter f (cdr xs)))
                                 (filter f (cdr xs)))))
^ filter ->

define (fix (^ foldr step init xs ->
	(isNil xs) init (step (car xs) (foldr step init (cdr xs)))))
^ foldr ->

define (^ f x -> x) ^ 0 ->
define (^ n f x -> f (n f x)) ^ succ ->

define (succ 0) ^ 1 ->
define (succ 1) ^ 2 ->
define (succ 2) ^ 3 ->
define (succ 3) ^ 4 ->
define (succ 4) ^ 5 ->
define (succ 5) ^ 6 ->
define (succ 6) ^ 7 ->
define (succ 7) ^ 8 ->
define (succ 8) ^ 9 ->
define (succ 9) ^ 10 ->

define (^ n f x -> (n (^ h g -> g (h f)) (^ g -> x) id)) ^ prec ->

define (^ n m -> n succ m) ^ add ->
define (^ n m -> m prec n) ^ minus ->
define (^ n m f -> m (n f)) ^ mult ->
define (^ n m -> m (mult n) 1) ^ exponential ->

define (^ n -> n (const true) false) ^ isPositive ->
define (^ n -> n (const false) true) ^ isZero ->
define (^ n m -> and (isZero (minus n m)) (isZero (minus m n))) ^ equal ->
define (^ n m -> or (isPositive (minus n m)) (isPositive (minus m n))) ^ notEqual ->

define (fix (^ len xs -> (isNil xs) 0 (succ (len (cdr xs))))) ^ length ->

define (fix (^ fac n -> (isZero n) 1 (mult n (fac (prec n))))) ^ factorial ->

define (fix (^ gen n -> (isZero n) nil (cons n (gen (prec n))))) ^ genList ->

define ((fix (^ isOk n ks k -> (isNil ks)
    true
    (and (notEqual k (car ks))
    (and (notEqual (add n k) (car ks))
    (and (notEqual k (add n (car ks)))
         (isOk (succ n) (cdr ks) k)))))) 1)
^ isValidNQ ->

define ((fix (^ isOk n ks k -> (isNil ks)
    true
    (and (notEqual k (car ks))
         (isOk (succ n) (cdr ks) k)))) 1)
^ isValidNR ->

define (^ size -> (fix (^ search n ks ->
    (isZero n)
        (cons ks)
        (foldr (^ f g x -> f (g x)) id (map (search (prec n))
            (map (^ k -> cons k ks) (filter (isValidNQ ks) (genList size)))))))
	size nil nil)
^ searchNQ ->

define (^ size -> (fix (^ search n ks ->
    (isZero n)
        (cons ks)
        (foldr (^ f g x -> f (g x)) id (map (search (prec n))
            (map (^ k -> cons k ks) (filter (isValidNR ks) (genList size)))))))
	size nil nil)
^ searchNR ->

;; car (searchNQ 8) z
length (genList 4) f x
;;factorial 3 f x
;;equal (exponential 2 10) (exponential 2 10) t f
